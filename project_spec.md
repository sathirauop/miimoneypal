# Project Specification: MiiMoneyPal (MVP) v3

## Project Description

**Project Name:** MiiMoneyPal

**Core Philosophy:** Minimal friction for data entry; clear visualization of cash flow, spending, and savings.

**High-Level Overview:** A web-based and mobile app for personal finance designed to track monthly cash flow (Income vs. Expenses) and savings contributions (Investments/Goals). The application prioritizes speed of entry for daily expenses to prevent user fatigue, while providing a detailed dashboard for monthly financial health analysis.

**What This App Does NOT Do:**

- Track investment returns or asset appreciation
- Calculate net worth
- Monitor portfolio performance

Buckets (Unit Trusts, Car Fund, etc.) record **cash contributions only** â€” not market value.

---

## 1. Project Philosophy

**Type:** Monthly Budget & Cash Flow Tracker.

**Core Principle:** "Control the Flow."

MiiMoneyPal tracks how money moves In (Income), Out (Expenses), and into Buckets (Investments/Goals). It prioritizes the user's daily "Usable Cash" balance above all else.

---

## 2. Core Logic & Math

### A. The Primary Metric: "Usable Amount"

This is the liquid cash available to spend within the current month.

**Formula:**

```
Monthly Usable = Opening Balance + Î£ Income + Î£ Withdrawals - Î£ Expenses - Î£ Investments
```

Where all transactions are filtered to the **selected month only**.

> **Note:** `GOAL_COMPLETED` transactions do not appear in this formula. When a savings goal is "marked as spent," the money is considered spent externally (e.g., you bought the car). It does not return to Usable Amount.

### B. The Secondary Metric: "Savings Flow"

**Monthly Savings Flow:** Tracks how much was set aside this month.

```
Monthly Savings Flow = Î£ Investments (This Month) - Î£ Withdrawals (This Month)
```

**Bucket Balance:** Tracks total cash contributed to a specific Goal/Asset.

```
Bucket Balance = Î£ (All Investments to Bucket) - Î£ (All Withdrawals from Bucket) - Î£ (GOAL_COMPLETED for Bucket)
```

> **Note:** Unlike Usable Amount (monthly-scoped), Bucket Balance is **cumulative across all time**. This represents total cash contributed to a goal regardless of which month the contribution was made.

---

## 3. Feature Requirements

### A. Transactions

#### User Transaction Types (4 Types)

Users interact with the system via four distinct transaction types.

**Fields:** Date, Amount, Type, Category/Bucket, Note (Optional, max 255 chars).

| Type       | Direction    | Effect on Usable Amount | Effect on Bucket Balance |
| ---------- | ------------ | ----------------------- | ------------------------ |
| Income     | In           | Increases (+)           | None                     |
| Expense    | Out          | Decreases (-)           | None                     |
| Investment | Transfer Out | Decreases (-)           | Increases (+)            |
| Withdrawal | Transfer In  | Increases (+)           | Decreases (-)            |

#### System Transaction Types (Auto-Generated)

Users cannot manually create these transaction types. They are generated by the system.

| Type           | Created By                      | Purpose                                           | Effect on Usable Amount  | Effect on Bucket Balance |
| -------------- | ------------------------------- | ------------------------------------------------- | ------------------------ | ------------------------ |
| GOAL_COMPLETED | System ("Mark as Spent" action) | Record that savings goal was spent on its purpose | None (money left system) | Decreases to 0           |

### B. Categorization System

**Income/Expense:** Must have a Category.

**Category-Transaction Type Matching:**

- Income transactions can **only** use categories of type `INCOME`
- Expense transactions can **only** use categories of type `EXPENSE`
- API must validate and reject mismatches with error: "Category type does not match transaction type"

**Investment/Withdrawal:** Must have a Bucket (Asset/Goal).

**Constraint:** A Category cannot be hard-deleted if it is assigned to existing transactions.

### C. Bucket Logic (Goals vs. Assets)

#### Type 1: SAVINGS_GOAL (e.g., "Car Fund")

**Features:**

- Optional "Target Amount"
- Progress bar showing percentage toward target

**Action: "Mark as Spent"**

This action records that the saved money was used for its intended purpose (e.g., you bought the car). The money is considered **spent externally** â€” it does not return to Usable Amount.

Implementation:

1. System creates a `GOAL_COMPLETED` transaction equal to current bucket balance
2. Transaction note auto-populated: "Goal completed: {bucket_name}"
3. Bucket status set to `ARCHIVED`
4. Bucket balance becomes 0
5. **Usable Amount is NOT affected** (the money was spent on the goal, not returned to cash)
6. Archived buckets visible in a separate "Completed Goals" section

**Example:**

- You saved LKR 500,000 in "Car Fund"
- You buy the car (external transaction, not tracked in app)
- You tap "Mark as Spent" to record that the goal is complete
- Bucket balance â†’ 0, Usable Amount â†’ unchanged

**Confirmation:** User must confirm action via a prompt.

**Reversal: "Reopen Goal"**

If a user accidentally marked a goal as spent, or wants to continue saving for the same goal:

1. User taps "Reopen" on archived goal
2. Prompt: "Enter amount to start this goal with"
3. Creates Investment transaction (reduces Usable Amount, increases Bucket Balance)
4. Bucket status changes from `ARCHIVED` to active

> **Note:** Reopening does not "undo" the original GOAL_COMPLETED. It starts fresh. If the user enters an amount greater than their current Usable Amount, Usable Amount will become negative (warning displayed).

#### Type 2: PERPETUAL_ASSET (e.g., "Unit Trusts")

**Features:**

- No Target Amount
- No "Mark as Spent" action

**Deletion:** Can only be deleted if Current Balance is 0.

### D. Data Management

**Initial Setup:** On first use, user is prompted to enter their current available cash as an Opening Balance (stored as an Income transaction with category "Opening Balance").

**Corrections:** User can Edit/Delete past transactions.

**Backdating:** Supported (user can add transactions for past dates).

**Opening Balance Strategy:**

- Treated as a regular Income transaction with category "Opening Balance"
- One per month (app prevents duplicates)
- Editable like any other transaction
- Must be dated on the 1st of the month

**Opening Balance Constraints:**

- Only ONE Opening Balance transaction allowed per month per user
- If user attempts to add another, show: "Opening balance already exists for this month. Would you like to edit it?"
- Category "Opening Balance" is system-protected (cannot be deleted or archived)

**Deletion Policy (Categories & Buckets):**

| Action  | Condition             | Behavior                                                                |
| ------- | --------------------- | ----------------------------------------------------------------------- |
| Delete  | No transactions exist | Hard delete permitted                                                   |
| Archive | Transactions exist    | Soft delete (hidden from dropdowns, visible in history)                 |
| Merge   | User requests         | Reassign all transactions to target category/bucket, then delete source |

**UI Flow for Deletion Attempt:**

- If transactions exist, show: "This category has X transactions. Would you like to Archive it or Merge into another category?"
- Archived items accessible via Settings â†’ "Manage Archived Items"
- Archived categories/buckets can be restored

### E. Monthly Model

Each calendar month operates as an **independent financial period**.

**Opening Balance:**

- First transaction of each month should be an Income with category "Opening Balance"
- Represents cash carried forward OR fresh start amount
- User can enter any amount (doesn't have to match previous month's ending)

**Month Rollover Prompt:**

On first app open after month changes, prompt user:

- "Last month you ended with LKR X. Use this as your opening balance?"
- **Accept:** Creates Income transaction (Opening Balance, amount X, dated 1st of new month)
- **Edit:** User can modify the amount before confirming
- **Skip:** User can dismiss and add manually later
- Prompt reappears on next app open until opening balance exists for current month

**First-Time User Flow:**

- No rollover prompt on first month (no previous data exists)
- Instead, show: "Welcome! Enter your current available cash to get started."
- Creates Opening Balance transaction for current month

**Dashboard Scope:**

- All metrics (Usable Amount, Income, Expenses, Savings) are scoped to the selected month
- User can navigate between months via month picker
- No cross-month calculations for Usable Amount

### F. System Categories

**System Categories (Seeded on Registration, Protected):**

| Name            | Type   | System Protected | Notes                             |
| --------------- | ------ | ---------------- | --------------------------------- |
| Opening Balance | INCOME | Yes              | Cannot delete, archive, or rename |

**User Default Categories (Seeded on Registration, User Can Modify):**

**Income:**

- Salary
- Freelance
- Gifts
- Other Income

**Expense:**

- Food & Dining
- Transportation
- Utilities
- Entertainment
- Shopping
- Healthcare
- Other Expense

---

## 4. Security & User Management

### A. Authentication

**Requirement:** Users must log in to access the dashboard.

**Methods:** Simple Email/Password or Social Login (e.g., Google) to reduce friction.

### B. Authorization (Data Isolation)

**Strict Rule:** Every API request must validate that the `user_id` in the JWT matches the owner of the requested data.

**Constraint:** A user can **never** access, edit, or delete another user's transactions, categories, or buckets.

---

## 5. Dashboard & UI Requirements

### A. View 1: The Monthly Dashboard (Home)

**Hero Section:**

- Month Picker (e.g., "January 2025" with left/right arrows)
- Current Month Usable Amount (Large, prominent)
- Opening Balance indicator (small, below main amount)

**Month Picker Behavior:**

- Navigate to any past month with existing transactions
- Cannot navigate to future months
- Empty months show: "No transactions this month" with option to add Opening Balance
- "Today" button returns to current month

**Monthly Stats:**

- Opening Balance
- Total Income (excluding Opening Balance)
- Total Expenses
- Total Invested
- Total Withdrawn
- **Ending Balance** = Opening + Income + Withdrawals - Expenses - Investments

**Recent Activity:** List last 5 transactions for the selected month.

**Link:** "View All" button leading to a full Transaction History page (filtered by selected month).

### B. View 2: The Buckets Tab

**List View:** Shows all Goals and Assets (active, not archived).

**Visualization:**

- If Target exists: Show Progress Bar with percentage
- If No Target: Show only Total Accumulated amount

**Sections:**

- Active Goals (SAVINGS_GOAL with balance > 0)
- Active Assets (PERPETUAL_ASSET)
- Completed Goals (Archived SAVINGS_GOAL) â€” collapsible section

---

## 6. Technical Constraints

### A. Data Model Decisions

**Single Pool Liquidity:** One aggregate "Usable Amount" (No separate Bank/Wallet accounts).

**Date Boundaries:** Strict Calendar Month (1stâ€“last day of month).

**Monthly Scope:** All Usable Amount calculations are scoped to calendar month. Cross-month queries are not supported in MVP.

**Currency:** User selects symbol (LKR, $, etc.), backend uses `DECIMAL(15,2)`.

**No Recurring Transactions:** Manual entry only for MVP.

### B. Edge Case Logic

**Negative Usable Amount:** Allowed (Show Red Warning in UI).

**Negative Bucket Balance:** Strictly Blocked. API must reject any withdrawal that would result in negative bucket balance.

**Partial Withdrawals:** Supported naturally. (Withdrawal reduces bucket balance; "Mark as Spent" archives whatever remains).

**Category/Bucket Deletion:** If transactions exist, hard deletion is blocked. Only archive or merge is permitted.

### C. MVP Utilities

**Export:** "Download CSV" of all transactions (with month filter option).

**Search/Filter:** Dropdowns for Month and Category on the "View All" page.

---

## IMPORTANT: Development Strategy

**MVP:** Backend and Frontend (Web)

**V1:** Mobile app with Flutter

**The Strategy:** Build the Backend as if the Mobile App already exists. Keep the API stateless (JWT) and strict (JSON). When ready for V1 (Mobile), simply point the Flutter app to the existing endpoints.

---

## Technical Specifications

### Tech Stack

#### Backend

| Component   | Selection             | Why this matters                                                     |
| ----------- | --------------------- | -------------------------------------------------------------------- |
| Language    | Java 21               | LTS, Virtual Threads, Records                                        |
| Framework   | Spring Boot 3.4.1     | Latest stable LTS                                                    |
| Database    | PostgreSQL 16         | The gold standard for relational data                                |
| Data Access | jOOQ                  | Type-safe SQL. No Hibernate magic. You write SQL in Java.            |
| Build Tool  | Gradle                | Easier to configure jOOQ Code Generator tasks than Maven             |
| Migration   | Flyway                | Required: jOOQ generates code from DB, so migrations must come first |
| Security    | Spring Security + JWT | Stateless authentication                                             |

#### Frontend

**Core Framework:**

- Build Tool: Vite
- Library: React 18
- Language: JavaScript (ES6+)

**State Management:**

- Server State (Caching/API): TanStack Query v5 (React Query)
- Client State (Auth/UI): Redux Toolkit

**Styling & UI:**

- CSS Framework: Tailwind CSS
- Component Library: Shadcn/UI (based on Radix Primitives)
- Icons: Lucide React

**Navigation & Data:**

- Routing: React Router DOM (v6)
- HTTP Client: Axios

**Forms & Validation:**

- Form Handling: React Hook Form
- Schema Validation: Zod

---

## 7. Technical Architecture

**Crucial:** This project implementation MUST strictly adhere to the coding standards, folder structure, and design patterns defined below.

### 7.1 Executive Summary

This project follows a **Modular Monolithic** architecture pattern organized by **Feature**, enforcing **Clean Architecture** principles within each feature module.

**Key Principles:**

- **Vertical Slicing:** Code is organized by business domain (e.g., transaction, bucket) rather than technical layer (e.g., controllers, services).
- **Endpoint-Centric:** Each REST endpoint has its own dedicated package containing all logic required for that specific operation.
- **Strict Layering:** Business logic (Use Cases) never depends on implementation details (Repositories/Presenters), only on Interfaces.
- **Type Safety:** Heavy use of Java Records, Enums, and custom Exceptions to ensure compile-time safety.

### 7.2 Project Structure

**Rule:** `com.<organization>.<project_name>`

```
com.organization.miimoneypal/
â”œâ”€â”€ Application.java                        (Spring Boot entry point)
â”œâ”€â”€ architecture/                           (Core architecture interfaces)
â”‚   â”œâ”€â”€ UseCase.java                        (Base use case interface)
â”‚   â””â”€â”€ AuthenticatedUseCase.java           (For authenticated operations)
â”œâ”€â”€ rest/                                   (The Core - Vertical Slices)
â”‚   â”œâ”€â”€ WelcomeController.java              (Root controller)
â”‚   â”œâ”€â”€ auth/                               (Authentication endpoints)
â”‚   â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â”œâ”€â”€ register/
â”‚   â”‚   â””â”€â”€ refresh/
â”‚   â”œâ”€â”€ transactions/
â”‚   â”‚   â”œâ”€â”€ get/
â”‚   â”‚   â”œâ”€â”€ post/
â”‚   â”‚   â”œâ”€â”€ put/
â”‚   â”‚   â””â”€â”€ delete/
â”‚   â”œâ”€â”€ categories/
â”‚   â”‚   â”œâ”€â”€ get/
â”‚   â”‚   â”œâ”€â”€ post/
â”‚   â”‚   â”œâ”€â”€ put/
â”‚   â”‚   â”œâ”€â”€ delete/
â”‚   â”‚   â”œâ”€â”€ archive/
â”‚   â”‚   â”œâ”€â”€ restore/
â”‚   â”‚   â””â”€â”€ merge/
â”‚   â”œâ”€â”€ buckets/
â”‚   â”‚   â”œâ”€â”€ get/
â”‚   â”‚   â”œâ”€â”€ post/
â”‚   â”‚   â”œâ”€â”€ put/
â”‚   â”‚   â”œâ”€â”€ delete/
â”‚   â”‚   â”œâ”€â”€ markspent/
â”‚   â”‚   â””â”€â”€ reopen/
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”œâ”€â”€ summary/
â”‚   â”‚   â”œâ”€â”€ previousbalance/
â”‚   â”‚   â””â”€â”€ availablemonths/
â”‚   â””â”€â”€ settings/
â”‚       â”œâ”€â”€ get/
â”‚       â””â”€â”€ put/
â”œâ”€â”€ security/                               (Spring Security configuration)
â”‚   â”œâ”€â”€ AppUser.java                        (UserDetails implementation)
â”‚   â”œâ”€â”€ Role.java                           (Role enum)
â”‚   â””â”€â”€ jwt/                                (JWT specific logic)
â”œâ”€â”€ config/                                 (Spring configurations)
â”‚   â”œâ”€â”€ SecurityConfig.java
â”‚   â”œâ”€â”€ WebConfig.java                      (CORS, Jackson settings)
â”‚   â””â”€â”€ JwtProperties.java                  (@ConfigurationProperties)
â”œâ”€â”€ exception/                              (Global Error Handling)
â”‚   â”œâ”€â”€ GlobalExceptionHandler.java
â”‚   â””â”€â”€ response/                           (Error DTOs)
â”œâ”€â”€ models/                                 (Common Response wrappers)
â”‚   â””â”€â”€ response/
â”‚       â”œâ”€â”€ ApiResponse.java                (Marker interface)
â”‚       â””â”€â”€ OffsetSearchResponse.java       (Pagination wrapper)
â”œâ”€â”€ records/                                (Domain Entities & DTOs)
â”‚   â”œâ”€â”€ transaction/
â”‚   â”œâ”€â”€ category/
â”‚   â”œâ”€â”€ bucket/
â”‚   â””â”€â”€ user/
â”œâ”€â”€ repository/                             (Global/Shared Repositories)
â”‚   â””â”€â”€ UserRepository.java
â”œâ”€â”€ service/                                (Shared Services)
â”‚   â””â”€â”€ CategorySeederService.java          (Seeds default categories on registration)
â””â”€â”€ constants/
    â””â”€â”€ EndPoints.java                      (Centralized URL paths)
```

### 7.3 Database Access Strategy

**Technology:** jOOQ (Type-safe SQL DSL)

**Rule:** Use jOOQ DSL for all queries. Inject `DSLContext` into Repository implementations. NEVER use native SQL strings.

**DDL Management:** Flyway migrations (never use JPA auto-DDL in production).

**Repository Organization:**

- **Local Repository (90%):** Lives in `rest/{feature}/{action}/`. Specific to one endpoint.
- **Global Repository (10%):** Lives in `repository/`. Shared across multiple features. **Criteria:** If 3+ endpoints need the same query â†’ Global Repository.

### 7.4 The "Endpoint-Per-Package" Standard

Every REST endpoint gets its own dedicated package containing all classes required for that operation.

**Path Example:** `rest/transactions/post/` (Creating a Transaction)

| File                                | Type       | Responsibility                            | Required |
| ----------------------------------- | ---------- | ----------------------------------------- | -------- |
| PostTransactionRequest.java         | Record     | Input DTO with @Valid annotations         | Always   |
| PostTransactionResponse.java        | Record     | Output DTO (implements ApiResponse)       | Always   |
| PostTransactionUseCase.java         | Service    | Business logic orchestrator               | Always   |
| PostTransactionDataAccess.java      | Interface  | Contract for database operations          | Always   |
| PostTransactionRepository.java      | Repository | Implementation using jOOQ                 | Always   |
| PostTransactionResponseBuilder.java | Interface  | Contract for Domain -> DTO transformation | Always   |
| PostTransactionPresenter.java       | Component  | Implementation of the builder             | Always   |

### 7.5 Implementation Patterns

#### The Controller (Thin Layer)

Controllers contain NO business logic. They only handle HTTP routing, validation triggers, and delegate to the UseCase.

```java
@RestController
@RequestMapping(EndPoints.Transactions.BASE)
@RequiredArgsConstructor
public class TransactionController {

    private final PostTransactionUseCase postTransactionUseCase;

    @PostMapping
    public ResponseEntity<PostTransactionResponse> createTransaction(
            @Valid @RequestBody PostTransactionRequest request
    ) {
        PostTransactionResponse response = postTransactionUseCase.execute(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}
```

#### The Use Case (The Orchestrator)

Use Cases define the "What", not the "How". They inject Interfaces, not Classes.

```java
@Service
@RequiredArgsConstructor
public class PostTransactionUseCase {

    private final PostTransactionDataAccess repository;
    private final PostTransactionResponseBuilder presenter;

    @Transactional
    public PostTransactionResponse execute(PostTransactionRequest request) {
        // 1. Business Validation
        validateCategoryMatchesTransactionType(request);

        // 2. Domain Logic
        Transaction transaction = buildTransaction(request);
        Transaction saved = repository.create(transaction);

        // 3. Delegate to Presenter
        return presenter.build(saved);
    }
}
```

#### The Presenter (Response Transformation)

Logic for how data is presented belongs here, not in the Use Case.

```java
@Component
@RequiredArgsConstructor
public class PostTransactionPresenter implements PostTransactionResponseBuilder {

    @Override
    public PostTransactionResponse build(Transaction transaction) {
        return new PostTransactionResponse(
            transaction.id(),
            transaction.amount(),
            formatDate(transaction.transactionDate())
        );
    }
}
```

### 7.6 Naming Conventions

| Component                | Convention                  | Example                        |
| ------------------------ | --------------------------- | ------------------------------ |
| Request                  | {Verb}{Noun}Request         | PostTransactionRequest         |
| Response                 | {Verb}{Noun}Response        | PostTransactionResponse        |
| Use Case                 | {Verb}{Noun}UseCase         | PostTransactionUseCase         |
| DB Interface             | {Verb}{Noun}DataAccess      | PostTransactionDataAccess      |
| DB Implementation        | {Verb}{Noun}Repository      | PostTransactionRepository      |
| Presenter Interface      | {Verb}{Noun}ResponseBuilder | PostTransactionResponseBuilder |
| Presenter Implementation | {Verb}{Noun}Presenter       | PostTransactionPresenter       |

### 7.7 Endpoint Constants

```java
public final class EndPoints {
    public static final String API = "/api/v1";

    public static final class Auth {
        public static final String BASE = API + "/auth";
        public static final String LOGIN = BASE + "/login";
        public static final String REGISTER = BASE + "/register";
        public static final String REFRESH = BASE + "/refresh";
    }

    public static final class Transactions {
        public static final String BASE = API + "/transactions";
    }

    public static final class Categories {
        public static final String BASE = API + "/categories";
        public static final String ARCHIVE = "/{id}/archive";
        public static final String RESTORE = "/{id}/restore";
        public static final String MERGE = "/{id}/merge";
    }

    public static final class Buckets {
        public static final String BASE = API + "/buckets";
        public static final String MARK_SPENT = "/{id}/mark-spent";
        public static final String REOPEN = "/{id}/reopen";
    }

    public static final class Dashboard {
        public static final String BASE = API + "/dashboard";
        public static final String SUMMARY = BASE + "/summary";
        public static final String PREVIOUS_BALANCE = BASE + "/previous-ending-balance";
        public static final String AVAILABLE_MONTHS = BASE + "/available-months";
    }

    public static final class Settings {
        public static final String BASE = API + "/settings";
    }
}
```

### 7.8 Security Architecture

**Authentication:** JWT based, stateless.

**Authorization:** All endpoints (except auth) require valid JWT. User can only access their own data.

**Protection:**

- Public endpoints: `/api/v1/auth/**` â†’ `.permitAll()`
- Private endpoints: Everything else requires authentication

### 7.9 Error Handling

Use specific RuntimeExceptions that map to HTTP Status Codes via `GlobalExceptionHandler`.

| Exception                    | HTTP Status              |
| ---------------------------- | ------------------------ |
| ValidationException          | 400 Bad Request          |
| AuthenticationException      | 401 Unauthorized         |
| ForbiddenException           | 403 Forbidden            |
| ResourceNotFoundException    | 404 Not Found            |
| ConflictException            | 409 Conflict             |
| UnprocessableEntityException | 422 Unprocessable Entity |

### 7.10 JSON Serialization

**Rule:** Database uses `snake_case`, API uses `snake_case`, Java uses `camelCase`.

Use `Jackson2ObjectMapperBuilderCustomizer` to set `PropertyNamingStrategies.SNAKE_CASE`.

---

## 8. Component Specifications (Frontend)

### A. AddTransactionDrawer

**Behavior:**

- Opens as bottom sheet (mobile) or modal (desktop)
- Adapts based on screen size using `useMediaQuery`

**Form Fields:**

- **Type Selector:** Income | Expense | Investment | Withdrawal (radio/toggle)
- **Amount:** Numeric input, required, positive numbers only
- **Date:** Date picker, defaults to today, allows past dates within selected month
- **Category Dropdown:** Shown only for Income/Expense types (filtered by matching type)
- **Bucket Dropdown:** Shown only for Investment/Withdrawal types
- **Note:** Optional text input, max 255 characters

**Actions:**

- **Submit:** POST to API â†’ invalidate TanStack Query cache â†’ close drawer
- **Cancel:** Close drawer without saving

### B. UsableAmountCard

**Display:**

- Large prominent number with currency symbol
- Green text if positive, Red text if negative
- Subtle animation on value change

### C. BucketCard

**Display:**

- Bucket name and type badge (Goal / Asset)
- Current balance
- Progress bar (only if targetAmount exists)
- Percentage complete (only if targetAmount exists)

**Actions:**

- Tap to view details/history
- "Mark as Spent" button (only for SAVINGS_GOAL with balance > 0)

### D. BottomNav

**Items:**

- Home (Dashboard) â€” icon: `home`
- Transactions â€” icon: `list`
- Add (+) â€” icon: `plus` (center, prominent, fab-style)
- Buckets â€” icon: `piggy-bank`
- Settings â€” icon: `cog`

### E. MonthRolloverPrompt

**Trigger:** First app open when current month â‰  last active month AND no opening balance exists for current month.

**Display:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Start January 2025                     â”‚
â”‚                                         â”‚
â”‚  Your December ending balance was:      â”‚
â”‚  LKR 45,000                             â”‚
â”‚                                         â”‚
â”‚  Use this as your opening balance?      â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ LKR  45,000              [edit] â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                         â”‚
â”‚  [Skip for now]         [Confirm]       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Behavior:**

- Amount field is editable
- "Confirm" creates Income transaction (category: Opening Balance, date: 1st of month)
- "Skip" dismisses prompt, user can add manually later
- Prompt reappears on next app open until opening balance exists for current month

### F. WelcomePrompt (First-Time User)

**Trigger:** User has no transactions at all (brand new account).

**Display:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Welcome to MiiMoneyPal! ğŸ‘‹             â”‚
â”‚                                         â”‚
â”‚  Let's get started.                     â”‚
â”‚  How much cash do you have available    â”‚
â”‚  right now?                             â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ LKR  0                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                         â”‚
â”‚                        [Get Started]    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Behavior:**

- Amount field required, must be >= 0
- "Get Started" creates Opening Balance transaction for current month

---

## 9. API Endpoints

**Base URL:** `/api/v1`

### Authentication

```
POST   /auth/register
       Request:  { email, password }
       Response: { user_id, email, token }

POST   /auth/login
       Request:  { email, password }
       Response: { user_id, email, token }

POST   /auth/logout
       Response: { success: true }

POST   /auth/refresh
       Request:  { refresh_token }
       Response: { token, refresh_token }
```

### Transactions

```
GET    /transactions?year=2025&month=1
       Response: { data: [...], pagination: {...} }
       Notes: year and month are REQUIRED query parameters

POST   /transactions
       Request:  { type, amount, transaction_date, category_id?, bucket_id?, note? }
       Response: { id, type, amount, transaction_date, category?, bucket?, note, created_at }

       Validations:
       - If category is "Opening Balance": transaction_date must be 1st of the month
       - Only ONE Opening Balance per month allowed (returns 409 Conflict if duplicate)
       - category_id required for INCOME/EXPENSE types
       - bucket_id required for INVESTMENT/WITHDRAWAL types
       - Category type must match transaction type (INCOME category for INCOME transaction)
       - amount must be > 0

PUT    /transactions/{id}
       Request:  { type, amount, transaction_date, category_id?, bucket_id?, note? }
       Response: { id, type, amount, ... }
       Notes: Same validations as POST

DELETE /transactions/{id}
       Response: { success: true }
```

### Categories

```
GET    /categories
       Response: { data: [...] }
       Notes: Returns only active (non-archived) categories by default

GET    /categories?include_archived=true
       Response: { data: [...] }

POST   /categories
       Request:  { name, type }
       Response: { id, name, type, is_system, created_at }

PUT    /categories/{id}
       Request:  { name }
       Response: { id, name, type, ... }
       Notes: Cannot change type. Cannot edit system categories.

DELETE /categories/{id}
       Response: { success: true }
       Error Response: { error: "has_transactions", transaction_count: 5 }
       Notes: Returns error if transactions exist. Client should offer Archive/Merge.

POST   /categories/{id}/archive
       Response: { success: true }
       Notes: Cannot archive system categories

POST   /categories/{id}/restore
       Response: { success: true }

POST   /categories/{id}/merge
       Request:  { target_category_id }
       Response: { success: true, transactions_moved: 15 }
       Notes: Moves all transactions to target, then deletes source category
```

### Buckets

```
GET    /buckets
       Response: { data: [...] }
       Notes: Includes current_balance calculated field. Returns active and archived.

GET    /buckets?status=active
       Response: { data: [...] }
       Notes: Filter by status (active, archived)

POST   /buckets
       Request:  { name, type, target_amount? }
       Response: { id, name, type, target_amount, current_balance: 0, created_at }
       Notes: target_amount only valid for SAVINGS_GOAL type

PUT    /buckets/{id}
       Request:  { name, target_amount? }
       Response: { id, name, ... }
       Notes: Cannot change type

DELETE /buckets/{id}
       Response: { success: true }
       Error Response: { error: "has_balance", current_balance: 5000 }
       Notes: Only allowed if current_balance = 0

POST   /buckets/{id}/mark-spent
       Response: { success: true, goal_completed_transaction_id }
       Notes: Creates GOAL_COMPLETED transaction, archives bucket.
              Only for SAVINGS_GOAL with balance > 0.

POST   /buckets/{id}/reopen
       Request:  { restore_amount }
       Response: { success: true, investment_transaction_id }
       Notes: Creates Investment transaction with restore_amount, un-archives bucket.
              Warning returned if restore_amount > current usable amount.
```

### Dashboard

```
GET    /dashboard/summary?year=2025&month=1
       Response: {
         year: 2025,
         month: 1,
         opening_balance: 50000.00,
         has_opening_balance: true,
         total_income: 85000.00,
         total_expenses: 45000.00,
         total_invested: 20000.00,
         total_withdrawn: 5000.00,
         ending_balance: 75000.00,
         recent_transactions: [...]
       }
       Notes: year and month are REQUIRED

GET    /dashboard/previous-ending-balance
       Response: {
         year: 2024,
         month: 12,
         ending_balance: 45000.00,
         has_data: true
       }
       Notes: Returns previous month's ending balance for rollover prompt.
              has_data: false if no previous month data exists.

GET    /dashboard/available-months
       Response: {
         months: [
           { year: 2025, month: 1, has_opening_balance: true, transaction_count: 45 },
           { year: 2024, month: 12, has_opening_balance: true, transaction_count: 38 },
           { year: 2024, month: 11, has_opening_balance: false, transaction_count: 2 }
         ]
       }
       Notes: Returns all months with at least one transaction, ordered by date descending.
              Used by Month Picker to show navigable months.
```

### Settings

```
GET    /settings
       Response: { currency_symbol, email, created_at }

PUT    /settings
       Request:  { currency_symbol }
       Response: { currency_symbol, ... }
```

---

## 10. Frontend Architecture

### A. Tech Stack

| Layer        | Technology                   |
| ------------ | ---------------------------- |
| Build Tool   | Vite                         |
| Framework    | React 18+                    |
| Routing      | React Router DOM v6          |
| Server State | TanStack Query (React Query) |
| Client State | Redux Toolkit + localStorage |
| Styling      | Tailwind CSS + Shadcn/UI     |
| PWA          | vite-plugin-pwa              |

### B. State Management Strategy

| State Type   | Solution                                                      |
| ------------ | ------------------------------------------------------------- |
| Server State | TanStack Query (transactions, categories, buckets, dashboard) |
| Auth State   | Redux + localStorage (token persistence)                      |
| UI State     | Redux (drawer open/close, selected month, active filters)     |

### C. Folder Structure

```
src/
â”œâ”€â”€ assets/                    # Static images/icons
â”œâ”€â”€ components/                # Shared UI Components
â”‚   â”œâ”€â”€ ui/                    # Shadcn components
â”‚   â””â”€â”€ Layout/
â”‚       â”œâ”€â”€ Layout.tsx
â”‚       â”œâ”€â”€ BottomNav.tsx
â”‚       â””â”€â”€ ProtectedRoute.tsx
â”‚
â”œâ”€â”€ features/                  # Feature modules
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”œâ”€â”€ authSlice.ts
â”‚   â”‚   â”œâ”€â”€ Login.tsx
â”‚   â”‚   â”œâ”€â”€ Register.tsx
â”‚   â”‚   â””â”€â”€ useAuth.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”œâ”€â”€ Dashboard.tsx
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚       â”œâ”€â”€ UsableAmountCard.tsx
â”‚   â”‚       â”œâ”€â”€ MonthlyStatsChart.tsx
â”‚   â”‚       â”œâ”€â”€ RecentActivity.tsx
â”‚   â”‚       â”œâ”€â”€ MonthPicker.tsx
â”‚   â”‚       â”œâ”€â”€ MonthRolloverPrompt.tsx
â”‚   â”‚       â””â”€â”€ WelcomePrompt.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ transactions/
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”œâ”€â”€ TransactionHistory.tsx
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚       â””â”€â”€ AddTransactionDrawer.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ buckets/
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”œâ”€â”€ BucketsList.tsx
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚       â”œâ”€â”€ BucketCard.tsx
â”‚   â”‚       â”œâ”€â”€ AddBucketModal.tsx
â”‚   â”‚       â””â”€â”€ ReopenBucketModal.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ categories/
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â””â”€â”€ CategoryManager.tsx
â”‚   â”‚
â”‚   â””â”€â”€ settings/
â”‚       â”œâ”€â”€ api.ts
â”‚       â””â”€â”€ Settings.tsx
â”‚
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useMediaQuery.ts
â”‚   â””â”€â”€ useSelectedMonth.ts
â”‚
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ axios.ts
â”‚   â”œâ”€â”€ queryClient.ts
â”‚   â””â”€â”€ utils.ts
â”‚
â”œâ”€â”€ store/
â”‚   â”œâ”€â”€ index.ts
â”‚   â””â”€â”€ hooks.ts
â”‚
â”œâ”€â”€ App.tsx
â”œâ”€â”€ main.tsx
â””â”€â”€ vite-env.d.ts
```

### D. Routing Structure

```typescript
<Routes>
  {/* Public Routes */}
  <Route path="/login" element={<Login />} />
  <Route path="/register" element={<Register />} />

  {/* Protected Routes with Layout */}
  <Route
    element={
      <ProtectedRoute>
        <Layout />
      </ProtectedRoute>
    }
  >
    <Route path="/" element={<Dashboard />} />
    <Route path="/transactions" element={<TransactionHistory />} />
    <Route path="/buckets" element={<BucketsList />} />
    <Route path="/categories" element={<CategoryManager />} />
    <Route path="/settings" element={<Settings />} />
  </Route>
</Routes>
```

---

## 11. Testing Strategy

### Unit Tests (UseCases)

**Location:** `src/test/java/{package}/rest/{feature}/{action}/`

**Pattern:** Mock all dependencies (Repository, Presenter), test business logic only.

### Integration Tests (Repositories)

Use TestContainers for PostgreSQL to test actual DB operations with jOOQ.

### Controller Tests

Use `@WebMvcTest` with MockMvc to test HTTP status codes and request/response serialization.

---

## 12. Anti-Patterns to Avoid

- âŒ **DON'T** create "God" services (e.g., TransactionService with 20 methods)
- âœ… **DO** create focused UseCases (e.g., PostTransactionUseCase)

- âŒ **DON'T** inject Repositories into Controllers
- âœ… **DO** inject UseCases into Controllers

- âŒ **DON'T** build Response DTOs manually in UseCases
- âœ… **DO** delegate to Presenters

- âŒ **DON'T** use @Transactional on read-only methods
- âœ… **DO** use @Transactional only for write operations

- âŒ **DON'T** hardcode URLs in code
- âœ… **DO** use EndPoints constants

- âŒ **DON'T** allow cross-user data access
- âœ… **DO** validate user_id on every request

---

## 13. Future Considerations (Post-MVP)

These features are explicitly **out of scope** for MVP:

- Multi-account support (separate Wallet/Bank balances)
- Recurring transactions (auto-create monthly)
- Custom month start date (payday-based)
- Multi-currency with conversion rates
- Data sync across devices
- Budgets per category
- Reports and analytics (yearly trends)
- Dark mode
- Offline support (V1 mobile consideration)

---

## Changelog

### v3 (Current)

- Fixed GOAL_COMPLETED effect: Now correctly shows "None (money left system)" for Usable Amount
- Clarified "Mark as Spent" means money is spent externally, not returned to usable cash
- Added clarification note to Section 2A formula about GOAL_COMPLETED exclusion
- Updated Bucket Balance formula to include GOAL_COMPLETED deduction
- Clarified "Reopen Goal" behavior and warnings
- Changed API field from `initial_amount` to `restore_amount` for bucket reopen
- Added POST /transactions validation rules
- Added GET /dashboard/available-months endpoint
- Added `/reopen` to buckets folder structure
- Added missing endpoint constants (REOPEN, AVAILABLE_MONTHS)
- Added ReopenBucketModal to frontend components
- Minor formatting and consistency improvements
